package arrays;

import java.lang.reflect.Array;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Scanner;

public class CyclicRotation {

	public static int[] solution(int[] A, int k) {
		int chgArr[] = new int[A.length];
		ArrayDeque<Integer> deque = new ArrayDeque<>();
		int lastDex = 0;
		for (int i = 0; i < A.length; i++) {
			if (i + k < A.length) {
				deque.push(A[i]); // 배열의 범위가 넘어가기 전 내용물 Deque에 그대로 푸쉬
									// push는 unshift와 같은 역할로 앞에서 부터 채워진다.
			} else {
				lastDex = chgArr.length - 1;
				deque.push(A[lastDex]); // 배열의 범위가 넘어간 내용물은 배열 인자의 순서를 뒤에서 부터
				lastDex--; // 푸쉬하도록 진행한다.
			}
		}
		for (int j = 0; j <= chgArr.length; j++) {
			System.out.print(deque.pop()); // deque의 앞 쪽부터 내용물을 끄집어 낸다.
		}
		return chgArr;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int arr[] = new int[sc.nextInt()-1]; // 배열 크기 설정
		for (int j = 0; j < arr.length; j++) {
			arr[j] = sc.nextInt();
		}
		solution(arr, sc.nextInt()); // 이동 횟수 입력
	}

}
